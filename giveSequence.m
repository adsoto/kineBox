function varargout = giveSequence(vid_path,v,opType,imProcess,varargin)
% Creates an image sequence by modifying the source video frames
% seq = motionOperation(vid_path,v,opType,imProcess)
%  seq - 3D matrix of an image sequence
%  vid_path - path to video file or image sequence
%  v - structure of info about video (generated by defineVidObject)
%  opType - designates the type of operation ('mean','mean and roi')
%  imProcess - manipulation of video images ('none','enhance contrast')
%
% seq = motionOperation(vid_path,v,'mean roi sub',...
%   imProcess,imRoiMean,fr_num,Centroid,Rotation,dSample,imInvert)
% Subtracts the mean image from roi of every video frame
%   imRoiMean - Mean stablized image for the roi
%   fr_num - sequence of frame numbers to be included in mean image
%   Centroid - struction denoting the center of the roi (generated by tracker)
%   Rotation - rotation structure generated by tracker
%   dSample - logical that indicates whether to downsample the roi image
%   imInvert - logical that indicates whether to invert the images
%

% Developed by McHenryLab at UC Irvine


%% Process inputs

% imType
if strcmp(opType,'mean roi sub')
    
    % Mean image
    imRoiMean = varargin{1}; 
    
    % Extract frame numbers
    if nargin>4
        if length(varargin{2})>1
            fr_num = varargin{2};
        else
            % Max number of frames to analyze
            maxFrames = varargin{1};
            fr_num = [];
        end
    else
        maxFrames = 100;
        fr_num = [];
    end
    
    % Define data from inputs
    Centroid = varargin{3};
    Rotation = varargin{4};
    dSample = varargin{5};
    imInvert = varargin{6};
 
else
    error('Do not recognize opType');
end

% Define NumFrames
if isfield(v.UserData,'NumFrames')
    numFrames = v.UserData.NumFrames;
else
    numFrames = length(v.UserData.FileInfo);
end

% imProcessing
if strcmp(imProcess,'none')
    %Do nothing
    
elseif strcmp(imProcess,'enhance contrast')
    %Do nothing
else
    error('Do not recognize imProcessing');
end


%% Preliminaries

% Check for image sequence
if ~isdir(vid_path)
    error('This function requires that the video is saved as a series of images')
end
   
% If frame numbers not provided . . .
if isempty(fr_num)
    
    % Proportion of video duration to exclude, from the beginning
    exclude_prop = 0.2;
    
    % Define list of frame numbers, depending on max number of frames
    % requested
    if (1-exclude_prop)*numFrames > maxFrames
        dframe = floor(numFrames/maxFrames);
        frame1 = round(exclude_prop*numFrames);
        fr_num = frame1:dframe:numFrames;
        clear dframe frame1
    else
        %fr_num = 1:numFrames;
        fr_num = v.UserData.FirstFrame:v.UserData.LastFrame;
    end
end

% Invert, if requested
if imInvert
    imRoiMean = imcomplement(imRoiMean);
end


%% Step thru frames


 % Loop thru frames
    for i = 1:length(fr_num)
        
        % Current frame
        cFrame = fr_num(i);
        
        % Index for current frame in the data
        iFrame = find(Centroid.frames==cFrame);
    
        % Current parameters
        x = Centroid.x_pix(iFrame);
        y = Centroid.y_pix(iFrame);
        r = Centroid.r_pix;
        tform = Rotation(iFrame).tform_roi;
        theta = Centroid.theta;
        
        % Current image
        im = getFrame(vid_path,v,cFrame,imInvert,'gray');
        
        % Extract roi
        [bw_mask,im_roi,roi_rect,bw_roi,imStable] = giveROI('circular',...
            im,x,y,r,theta,dSample,tform);
                       
        % Adjust contrast 
        if i==1 && strcmp(imProcess,'enhance contrast')    
            
            imStable = imadjust(adapthisteq(imStable));
            
            if i==1
                % Adjust mean image
                imRoiMean = imadjust(adapthisteq(imRoiMean));
            end
        end

        
        % Define mask
        if i==1
            roi_rect = [round(x-r) round(y-r) ceil(r*2) ceil(r*2)];
            
            % Redefine mask with smaller r
            [tmp1,tmp2,tmp3,Mask,tmp4] = giveROI('circular',...
                im,x,y,r-1,theta,dSample,tform,roi_rect);
            
            Mask = ~Mask;
            % White out region outside of circle
            %imRoiMean(~bw_roi) = 255;
            
            clear roi_rect tmp1 tmp2 tmp3 tmp4
        end
        
        % Subtract background
        warning off
        if imInvert
            imCurr = imadjust(uint8(imcomplement(imsubtract(imRoiMean,imStable))));
        else
            imCurr = imadjust(uint8(imcomplement(imsubtract(imStable,imRoiMean))));
        end
        warning on
        
        imCurr(Mask) = 255;
        
        % Store image
        im_seq(:,:,i) = imCurr;
        
        % Visualize
        if 0
            subplot(2,2,1)
            imshow(imStable,'InitialMagnification','fit');
            title('imStable')
            subplot(2,2,2)
            imshow(imRoiMean,'InitialMagnification','fit');
            title('mean image')
            subplot(2,2,3)
            warning off
            imshowpair(imStable,imRoiMean)
            warning on
            title('stable over mean image')
            subplot(2,2,4)
            imshow(im_seq(:,:,i),'InitialMagnification','fit');
            title('mean image subtraction')
            %title([num2str(cFrame)]
            pause(0.001);
        end
        
        % Clear for next
        clear x y r tform cFrame im theta im bw_mask im_roi roi_rect 
        clear bw_roi imStable
        
        % Update status
        disp(['motionOperation (' opType '): done ' num2str(i) ' of ' ...
            num2str(length(fr_num))]);       
    end

% % Loop through frames
% for i = 1:length(fr_num)
%     
%     cFrame = fr_num(i);
%     
%     % Index for current frame in the data
%     iFrame = find(Centroid.frames==cFrame);
%     
%     % Get current frame
%     imCurr       = getFrame(vid_path,v,cFrame);  
%     
%     % Convert to grayscale
%     imCurr = rgb2gray(imCurr);
% 
%     % Enhance contrast, if requested
%     if strcmp(imProcess,'enhance contrast') || strcmp(imType,'mean and roi')
%         imCurr = imadjust(imCurr);
%         
%         % roi data
%         if strcmp(imType,'mean and roi')
%             imStable = roiImage(imCurr,Centroid,Rotation,iFrame,dSample);
%         end
%     end
% 
%     % If mean image(s) . . .
%     if strcmp(imType,'mean') || strcmp(imType,'mean and roi')
%         
%         % Add current to total
%         imSum  = imSum + double(imCurr);
%         
%         if strcmp(imType,'mean and roi')            
%             % Sum matrix for stablized roi
%             imSum_roi  = imSum_roi + double(imStable);
%         end
%     end
%     
%     % Clear fopr next loop
%     clear imCurr
%     
%     % Update status
%     disp(['motionImage (' imType ') : ' num2str(i) ' of ' num2str(length(fr_num))])
%     
% end
% 
% % Calculate mean image(s)
% if strcmp(imType,'mean') || strcmp(imType,'mean and roi')
%     % Calculate mean from sum image
%     imMean = uint8(round(imSum./length(fr_num)));
%     
%     if strcmp(imType,'mean and roi')
%         imMeanROI = uint8(round(imSum_roi./length(fr_num)));
%     end
% end


%% Output results


varargout{1} = im_seq;



% function imStable = roiImage(im,Centroid,Rotation,iNum,dSample)
% % Returns stabilized roi image
% 
% % Extract current parameters
% x = Centroid.x_pix(iNum);
% y = Centroid.y_pix(iNum);
% r = Centroid.r_pix;
% theta = Centroid.theta;
% tform = Rotation(iNum).tform_roi;
% 
% % Extract roi
% [bw_mask,im_roi,roi_rect,bw_roi,imStable] = giveROI('circular',...
%     im,x,y,r,theta,dSample,tform);



