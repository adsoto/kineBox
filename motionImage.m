function varargout = motionImage(vid_path,v,imType,varargin)
% Creates a single image from a video sequence
% im = motionImage(vid_path,v,imType,imProcessing)
%  im - output image
%  vid_path - path to video file or image sequence
%  v - structure of info about video (generated by defineVidObject)
%  imType - designates the type of image ('mean','mean and roi')
%  imProcess - manipulation of video images ('none','enhance contrast')
%
%  im = motionImage(vid_path,v,'mean',imProcess,fr_num)
%  Returns mean image of provided frame numbers.
%  fr_num - column vector of frame numbers to be included in mean image,
%  or single integer for the max number of frames at an equal interval
%
%  [im,imROI] = motionImage(vid_path,v,'mean roi',imProcess,fr_num,S,dSample)
%  Returns mean image (im) and mean image for roi (imROI) for maxFrames 
%  at even intervals or frnums. 
%   S - structure for roi coorindate trasnformation (generated by
%       defineSystem2d('roi'))
%   dSample - logical that indicates whether to downsample the roi image
%
% im = motionImage(vid_path,v,'bw static',fr_num,B)
% Returns an image of the static elements in a binary image sequence
%   B - structure of blob data

% Developed by McHenryLab at UC Irvine


%% Process inputs

% imType
if strcmp(imType,'mean') 
    
    % Image processing
    imProcess = varargin{1};
    
    % Extract frame numbers
    if nargin>4
        if length(varargin{2})>1
            fr_num = varargin{2};
        else
            % Max number of frames to analyze
            maxFrames = varargin{2};
            fr_num = [];
        end
    else
        maxFrames = 100;
        fr_num = [];
    end
    
%     % Extract roi info
%     if strcmp(imType,'mean and roi')     
%         Centroid = varargin{3};
%         Rotation = varargin{4};
%         dSample  = varargin{5};
%     end
 
elseif strcmp(imType,'mean roi') 
    
    % Image processing
    imProcess = varargin{1};
    
    % Extract frame numbers
    if nargin>4
        if length(varargin{2})>1
            fr_num = varargin{2};
        else
            % Max number of frames to analyze
            maxFrames = varargin{2};
            fr_num = [];
        end
    else
        maxFrames = 100;
        fr_num = [];
    end
    
    S       = varargin{3};
    dSample = varargin{4};
    
elseif strcmp(imType,'bw static') 
    
    fr_num = varargin{1};
    B      = varargin{2};
    imProcess = [];
    
    if length(fr_num)<2
        error('fr_num must be a vector of at least 2 numbers')
    end
else
    error('Do not recognize imType');
end

if isfield(v.UserData,'NumFrames')
    numFrames = v.UserData.NumFrames;
else
    numFrames = length(v.UserData.FileInfo);
end

% imProcessing
if strcmp(imProcess,'none') || isempty(imProcess)
    %Do nothing
    
elseif strcmp(imProcess,'enhance contrast')
    %Do nothing
else
    error('Do not recognize imProcessing');
end


%% Preliminaries

% Check for image sequence
if ~isdir(vid_path)
    error('This function requires that the video is saved as a series of images')
end
   
% If frame numbers not provided . . .
if isempty(fr_num)
    
    % Proportion of video duration to exclude, from the beginning
    exclude_prop = 0.2;
    
    % Define list of frame numbers, depending on max number of frames
    % requested
    if (1-exclude_prop)*numFrames > maxFrames
        dframe = floor(numFrames/maxFrames);
        frame1 = round(exclude_prop*numFrames);
        fr_num = frame1:dframe:numFrames;
        clear dframe frame1
    else
        %fr_num = 1:numFrames;
        fr_num = v.UserData.FirstFrame:v.UserData.LastFrame;
    end
end
    
if strcmp(imType,'bw static')
    % Create sum image based on first frame
    imCurr = getFrame(vid_path,v,B(fr_num(1)).fr_num);    
else     
    % Create sum image based on first frame
    imCurr = getFrame(vid_path,v,fr_num(1));   
end

% Convert to grayscale
imCurr = rgb2gray(imCurr);

% Initialize mean image
if strcmp(imType,'mean') || strcmp(imType,'mean and roi')
    imSum = zeros(size(imCurr));
    
    % If also roi mean image . . .
    if strcmp(imType,'mean and roi')        
        imSum_roi = zeros(size(roiImage(imCurr,Centroid,Rotation,1,dSample)));
    end
end

clear imCurr 


%% Step thru frames

% Loop through frames
for i = 1:length(fr_num)

    % Current frame number
    cFrame = fr_num(i);

    % Load current image
    if strcmp(imType,'bw static')
        % Create sum image based on first frame
        imCurr = getFrame(vid_path,v,B(cFrame).fr_num);       
        
    elseif strcmp(imType,'mean') 
        % Get current frame
        imCurr       = getFrame(vid_path,v,cFrame,'gray');       
    
    elseif strcmp(imType,'mean roi') 
        % Get current frame
        im       = getFrame(vid_path,v,cFrame,'gray');     
        
        imCurr = giveROI('stabilized',im,S.roi(i),0,S.tform(:,:,i));
        
    end
    
    % Convert to grayscale
    imCurr = rgb2gray(imCurr);
    
    if strcmp(imType,'bw static')
        % Start with blank
        currIm  = logical(zeros(size(imCurr)));
    end

    % Enhance contrast, if requested
    if strcmp(imProcess,'enhance contrast') 
        imCurr = imadjust(imCurr);
    end

%TODO:Update code below

    % If mean image(s) . . .
    if strcmp(imType,'mean') 

        % Add current to total
        imSum  = imSum + double(imCurr);        
    
    elseif strcmp(imType,'mean roi') 
        
       
        % Index for current frame in the data
        iFrame = find(Centroid.frames==cFrame);
        
        % Get stable roi image
        imStable = roiImage(imCurr,Centroid,Rotation,iFrame,dSample);
        
        % Sum matrix for stablized roi
        imSum_roi  = imSum_roi + double(imStable);
        
    elseif strcmp(imType,'bw static') 
        
        % Loop thru blobs
        for k = 1:length(B(i).propsG),
            
            % Score pixels with blobs
            currIm(B(i).propsG(k).PixelIdxList) = 1;            
        end
        
        % Store resulting image
        bwStack(:,:,i) = currIm;
    end
    
    % Clear fopr next loop
    clear imCurr currIm
    
    % Update status
    disp(['motionImage (' imType ') : ' num2str(i) ' of ' num2str(length(fr_num))])
    
end

% Calculate mean image(s)
if strcmp(imType,'mean') || strcmp(imType,'mean and roi')
    % Calculate mean from sum image
    imOut = uint8(round(imSum./length(fr_num)));
    
    if strcmp(imType,'mean and roi')
        imOutROI = uint8(round(imSum_roi./length(fr_num)));
    end
    
% Create image from motion score    
elseif strcmp(imType,'bw static') 
    
    % image of the pixels that are most static
    imOut = uint8(sum(double(bwStack),3)./length(fr_num).*255);
    
end


%% Output results

if strcmp(imType,'mean') || strcmp(imType,'bw static') 
    varargout{1} = imOut;
    
elseif strcmp(imType,'mean and roi')
    varargout{1} = imOut;
    varargout{2} = imOutROI;
end


function imStable = roiImage(im,Centroid,Rotation,iNum,dSample)
% Returns stabilized roi image

% Extract current parameters
x = Centroid.x_pix(iNum);
y = Centroid.y_pix(iNum);
r = Centroid.r_pix;
theta = Centroid.theta;
tform = Rotation(iNum).tform_roi;

% Extract roi
[bw_mask,im_roi,roi_rect,bw_roi,imStable] = giveROI('circular',...
    im,x,y,r,theta,dSample,tform);



