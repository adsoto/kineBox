function varargout = tracker(vid_path,v,method,roiScale,imInvert,visTracking,...
                             frames,Centroid,Rotation,makeVid)
% Tracks a landmark or body
%
%  vid_path - path to video file or image sequence
%  v - structure of info about video (generated by defineVidObject)
%  method - type of tracking approach: 'threshold' (currently only method)
%  roiScale - Factor by which the blob diameter gets multiplied for roi
%  imInvert - choose 0 for light on dark field, 1 for dark on light field
%  visTracking - Logical to visualize the tracking
%  frames - listing of frame numbers to analyze
%  Centroid - structure with fields x_pix, y_pix, & r_pix for roi coord & radius
%
% Centroid = tracker(vid_path,v,'threshold translation') - returns just centroid cooridnates
%
% Developed by McHenryLab at UC Irvine


%% Parameter defaults

% Downsample images for image registration
dSample = 1;

% If frames undefined, or empty
if nargin < 7 || isempty(frames)
    
    % Frame numbers
    frames = v.UserData.FirstFrame:v.UserData.LastFrame;
    
    % If visTracking undefined . . .
    if nargin < 6
        % Turn on
        visTracking = 1;
        
        % If roiScale undefined . . .
        if nargin<4
            % Factor by which the blob diameter gets multiplied for roi
            roiScale = 1.3;
            
            % If method undefined . . .
            if nargin<3
                method = 'threshold translation';
            end
        end
    end
end

if nargin<10
    makeVid= 0;
end

% If threshold method . . .
if strcmp(method,'threshold translation')

    % Define frames
    Centroid.frames = frames;   
    
% If body rotation . . .
elseif strcmp(method,'body rotation')
    
    % Make sure Centroid data provided
    if nargin < 8
        error(['Centroid structure needs to be defined before analyzing '...
               'body rotation. Try threshold method to resolve centroid values']);
    end
   
% If visualization . . .
elseif  strcmp(method,'visualize') 
    
    % Make figure
    fig = figure;
    
    % If no rotation data
    if nargin < 8
        
        includeRot = 0;
        
        if nargin < 7
            error(['Centroid structure needs to be defined before analyzing '...
                'body rotation. Try threshold method to resolve centroid values']);
        end
        
    % If there is rotation data
    else
        includeRot = 1;
    end
    
% If no match on method
else
    error('requested method not recognized');
end

% Angular coordinates for circular roi
theta = linspace(0,2*pi,500);


%% Prompt for user input on first frame

% For threshold method
if strcmp(method,'threshold translation')
    % First image
    im = getFrame(vid_path,v,frames(1),imInvert,'gray');
    
    
    f = figure('DoubleBuffer','on');
    
    % Select sea star from first frame
    [tVal,x,y] = imInteract(im,'threshold and selection');
    
    Centroid.x_pix(1)      = x;
    Centroid.y_pix(1)      = y;
    Centroid.y_pix_flip(1) = size(im,1)-y;
    
    % If no visualization . . .
    if ~visTracking
        % Pause and close figure
        pause(0.5)
        close
    else
        hold off
    end
    
    clear x y 
end


%% Initial parameter values

% For threshold method: find initial blob diameter & perimeter
if strcmp(method,'threshold translation')
    
    % Return blobs
    [props,bwOut,areas,xPerim,yPerim] = findBlobs(im,tVal,'coord',...
            Centroid.x_pix,Centroid.y_pix);
    
    % Blob diameter & radius
    blobDiam = max([range(xPerim) range(yPerim)]);
    r        = roiScale*blobDiam/2;
    
    % Store radius
    Centroid.r_pix = r;
    
    clear xPerim yPerim bw r
    
elseif strcmp(method,'body rotation')
    
    % Initialize image registration parameters
    [optimizer, metric]  = imregconfig('monomodal');
    optimizer.MaximumStepLength = 5e-4;
    optimizer.MaximumIterations = 1500;
    optimizer.RelaxationFactor  = 0.2;
    
    % First image
    im0 = getFrame(vid_path,v,frames(1),imInvert,'gray');
    
    % Focus on roi
    %[im0,roi_mask,roi_rect] = isolate_roi(im0,Centroid.x_pix(1),Centroid.y_pix(1),Centroid.r_pix,theta);
    [bw_mask,im_roi0,roi_rect] = giveROI('circular',...
        im0,Centroid.x_pix(1),Centroid.y_pix(1),Centroid.r_pix,theta,dSample);
end


%% Tracking object

% Loop thru frames
for i = 1:length(frames)
    
    % Current frame
    cFrame = frames(i);
    
    % Current image
    im = getFrame(vid_path,v,cFrame,imInvert,'gray');
    
    % Threshold method: find centroid coordinates
    if strcmp(method,'threshold translation')
        
        [props,bwOut] = findBlobs(im,tVal,'coord',...
            Centroid.x_pix(end),Centroid.y_pix(end));
        
        % Update status
        disp(['Done centroid frame ' num2str(cFrame) '/' num2str(frames(end))])        
        
        % Store results
        Centroid.x_pix(i,1) = props.Centroid(1);
        Centroid.y_pix(i,1) = props.Centroid(2);
        Centroid.y_pix_flip(i,1) = size(im,1)-props.Centroid(2);
        
        % Don't include rotation in plotting
        includeRot = 0;
        
        % Clear for next loop
        clear tmp_x tmp_y
        
    % body rotation method: 
    elseif strcmp(method,'body rotation')
        
%         % Find rotation matrix
%         tform = findRot(im,im0,Centroid.x_pix(i),Centroid.y_pix(i),...
%                         Centroid.r_pix,theta,optimizer,metric);

         [bw_mask,im_roi,roi_rect,bw_roi] = giveROI('circular',...
             im,Centroid.x_pix(i),Centroid.y_pix(i),Centroid.r_pix,theta,dSample);
         
         % Focus on roi
%         [im_roi,imMask,roi_rect] = isolate_roi(im,Centroid.x_pix(i),...
%             Centroid.y_pix(i),Centroid.r_pix,theta);

         % Transformation object to stablize head wrt im0
         tform = imregtform(im_roi,im_roi0,'rigid',optimizer,metric);

         % Include rotation in plotting
         includeRot = 1;
           
         % Status update
         disp(['Rotation: completed ' num2str(i) ' of ' num2str(length(frames))])

        % Store results
        Rotation(i).tform_roi = tform;
        %Rotation(i).
        Rotation(i).roi_rect = roi_rect;
        
        
        % Clear for next iteration
        clear im_roi tform_roi imStable xC yC h imMask im_roi
    end
    
    % Visualize: 
    if strcmp(method,'visualize') || visTracking
        
        % Title text
        t_txt = ['Frame ' num2str(cFrame) '/' num2str(frames(end))];
            
        % If rotation data included . . .
        if includeRot
            visTrack(im,Centroid.x_pix(i),Centroid.y_pix(i),Centroid.r_pix,theta,...
                Rotation(i).tform_roi,t_txt,dSample);
            
        % If no rotation
        else

            % Visualization code
            visTrack(im,Centroid.x_pix(i),Centroid.y_pix(i),Centroid.r_pix,...
                theta,[],t_txt,dSampling);
        end
        
        % Log frame
        if makeVid
            M(i) = getframe(gcf);
        end
        
        % Pause briefly to render
        pause(0.001)
    end

end


%% Define outputs

% Threshold method
if strcmp(method,'threshold translation')
    
        varargout{1} = Centroid;
            
% Body rotation method    
elseif strcmp(method,'body rotation')
    
    varargout{1} = Rotation;
    
elseif strcmp(method,'visualize') 
    
    if makeVid
        varargout{1} = M;
    else
        varargout{1} = fig;
    end
end

% Report status
if ~visTracking
    disp(' ')
    disp([method ' complete!'])
end



function visTrack(im,x,y,r,theta,tform,t_txt,dSample)

% If rotation included . . 
if nargin>5 && ~isempty(tform)
    % Focus on roi
    %[im_roi,imMask,roi_rect] = isolate_roi(im,x,y,r,theta);
    
    [bw_mask,im_roi,roi_rect,bw_roi] = giveROI('circular',im,x,y,r,theta,0);
    
    %TODO: Fix the problem with skew in image
    
    % Stablize image
    imStable = imwarp(im_roi,tform,'OutputView',imref2d(size(im_roi)),...
        'FillValues',255,'SmoothEdges',true);
    
    % White out beyond roi
    imStable(~bw_roi) = 255;

    subplot(1,2,2)
    imshow(imStable,'InitialMagnification','fit');
    
    % Set up for main plot
    subplot(1,2,1)
end

% Circular coordinates for new roi
xC    = r.*cos(theta) + x;
yC    = r.*sin(theta) + y;

imshow(im,'InitialMagnification','fit');
hold on
h = line(xC,yC,'Color',[1 0 0 0.2],'LineWidth',3);
title(t_txt)
plot(x,y,'r+')
hold off




